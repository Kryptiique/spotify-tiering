const Sequelize = require('sequelize')
const uuid = require('uuid/v4')

const db = new Sequelize('app_sql', null, null, {
  dialect: 'sqlite',
  storage: './graphql_code/app_sql.db',
})

/**
 * This file essentially models the objects as they should appear on the
 * SQLite database.
 * 
 * As a side note, the database was originally generated by code created by
 * Amazon Web Services (AWS) for a DynamoDB database, so the conventions for 
 * tables are exactly the same. Not all fields are used by our app, but I
 * kept them around cause I was lazy. (lol)
 */

const CircleModel = db.define('Circle', {
  id: { type: Sequelize.UUIDV4, primaryKey: true, defaultValue: uuid() },
  __typename: { type: Sequelize.STRING, defaultValue: 'Circle' },
  createdAt: { type: Sequelize.STRING, defaultValue: new Date().toISOString() },
  updatedAt: { type: Sequelize.STRING, defaultValue: new Date().toISOString() },
  
  name: { type: Sequelize.STRING, allowNull: false  },
  description: { type: Sequelize.STRING, allowNull: false  },
  songCount: { type: Sequelize.INTEGER },
  ownerId: { type: Sequelize.STRING, allowNull: false  },
  image: { type: Sequelize.STRING, allowNull: false  },
  spotifyLink: { type: Sequelize.STRING, allowNull: false  },
  swapCap: { type: Sequelize.INTEGER },
  addCap: { type: Sequelize.INTEGER },
  initialAddCap: { type: Sequelize.INTEGER },
  frozen: { type: Sequelize.INTEGER },
  autoFreeze: { type: Sequelize.INTEGER },
  freezeSettings: { type: Sequelize.STRING },
  joinLink: { type: Sequelize.STRING },
  jointEffort: { type: Sequelize.INTEGER },
},{
  freezeTableName: true,
})

const UserModel = db.define('User', {
  id: { type: Sequelize.UUIDV4, primaryKey: true, defaultValue: uuid() },
  __typename: { type: Sequelize.STRING, defaultValue: 'User' },
  createdAt: { type: Sequelize.STRING, defaultValue: new Date().toISOString() },
  updatedAt: { type: Sequelize.STRING, defaultValue: new Date().toISOString() },
  
  username: { type: Sequelize.STRING, allowNull: false },
  profilePic: { type: Sequelize.STRING },
  reputation: { type: Sequelize.NUMBER, defaultValue: 0 },
  spotifyLink: { type: Sequelize.STRING, allowNull: false },
  active: { type: Sequelize.INTEGER},
  displayName: { type: Sequelize.STRING, allowNull: false },
  sortCategory: { type: Sequelize.STRING, allowNull: false, defaultValue:'DATEADDED'  },
  sortDirection: { type: Sequelize.STRING, allowNull: false, defaultValue:'ASC' },
},{
  freezeTableName: true,
})

const UCLinkModel = db.define('UCLink', {
  id: { type: Sequelize.UUIDV4, primaryKey: true, defaultValue: uuid() },
  __typename: { type: Sequelize.STRING, defaultValue: 'UCLink' },
  createdAt: { type: Sequelize.STRING, defaultValue: new Date().toISOString() },
  updatedAt: { type: Sequelize.STRING, defaultValue: new Date().toISOString() },
  
  linkCircleId: { type: Sequelize.STRING, allowNull: false },
  linkUserId: { type: Sequelize.STRING, allowNull: false },
  displayName: { type: Sequelize.STRING },
  reputation: { type: Sequelize.NUMBER, defaultValue: 0 },
},{
  freezeTableName: true,
})

const SongModel = db.define('Song', {
  id: { type: Sequelize.UUIDV4, primaryKey: true, defaultValue: uuid() },
  __typename: { type: Sequelize.STRING, defaultValue: 'Song' },
  createdAt: { type: Sequelize.STRING, defaultValue: new Date().toISOString() },
  updatedAt: { type: Sequelize.STRING, defaultValue: new Date().toISOString() },
  
  circleId: { type: Sequelize.STRING, allowNull: false },
  removeId: { type: Sequelize.STRING, allowNull: false },
  adderId: { type: Sequelize.STRING, allowNull: false },
  artist: { type: Sequelize.STRING, allowNull: false },
  album: { type: Sequelize.STRING, allowNull: false },
  albumArt: { type: Sequelize.STRING, allowNull: false },
  dateAdded: { type: Sequelize.STRING, allowNull: false },
  tier: { type: Sequelize.INTEGER},
  spotifyLink: { type: Sequelize.STRING, allowNull: false },
},{
  freezeTableName: true,
})

const ActionModel = db.define('Action', {
  id: { type: Sequelize.UUIDV4, primaryKey: true, defaultValue: uuid() },
  __typename: { type: Sequelize.STRING, defaultValue: 'Action' },
  createdAt: { type: Sequelize.STRING, defaultValue: new Date().toISOString() },
  updatedAt: { type: Sequelize.STRING, defaultValue: new Date().toISOString() },
  
  ownerId: { type: Sequelize.STRING, allowNull: false },
  circleId: { type: Sequelize.STRING, allowNull: false },
  image: { type: Sequelize.STRING, allowNull: false },
  message: { type: Sequelize.STRING, allowNull: false },
  link: { type: Sequelize.STRING, allowNull: false },
  date: { type: Sequelize.STRING, allowNull: false },
},{
  freezeTableName: true,
})

const SwapModel = db.define('Swap', {
  id: { type: Sequelize.UUIDV4, primaryKey: true, defaultValue: uuid() },
  __typename: { type: Sequelize.STRING, defaultValue: 'Swap' },
  createdAt: { type: Sequelize.STRING, defaultValue: new Date().toISOString() },
  updatedAt: { type: Sequelize.STRING, defaultValue: new Date().toISOString() },
  
  authorId: { type: Sequelize.STRING, allowNull: false },
  circleId: { type: Sequelize.STRING, allowNull: false },
  date: { type: Sequelize.STRING, allowNull: false },
  originalId: { type: Sequelize.STRING, allowNull: false },
  replacementId: { type: Sequelize.STRING, allowNull: false },
},{
  freezeTableName: true,
})

const CommentModel = db.define('Comment', {
  id: { type: Sequelize.UUIDV4, primaryKey: true, defaultValue: uuid() },
  __typename: { type: Sequelize.STRING, defaultValue: 'Comment' },
  createdAt: { type: Sequelize.STRING, defaultValue: new Date().toISOString() },
  updatedAt: { type: Sequelize.STRING, defaultValue: new Date().toISOString() },
  
  authorId: { type: Sequelize.STRING, allowNull: false },
  songId: { type: Sequelize.STRING, allowNull: false },
  date: { type: Sequelize.STRING, allowNull: false },
  body: { type: Sequelize.STRING, allowNull: false },
},{
  freezeTableName: true,
})

const UTLinkModel = db.define('UTLink', {
  id: { type: Sequelize.UUIDV4, primaryKey: true, defaultValue: uuid() },
  __typename: { type: Sequelize.STRING, defaultValue: 'UTLink' },
  createdAt: { type: Sequelize.STRING, defaultValue: new Date().toISOString() },
  updatedAt: { type: Sequelize.STRING, defaultValue: new Date().toISOString() },
  
  userId: { type: Sequelize.STRING, allowNull: false },
  threadId: { type: Sequelize.STRING, allowNull: false },
},{
  freezeTableName: true,
})

const ThreadModel = db.define('Thread', {
  id: { type: Sequelize.UUIDV4, primaryKey: true, defaultValue: uuid() },
  __typename: { type: Sequelize.STRING, defaultValue: 'Thread' },
  createdAt: { type: Sequelize.STRING, defaultValue: new Date().toISOString() },
  updatedAt: { type: Sequelize.STRING, defaultValue: new Date().toISOString() },
},{
  freezeTableName: true,
})

const MessageModel = db.define('Message', {
  id: { type: Sequelize.UUIDV4, primaryKey: true, defaultValue: uuid() },
  __typename: { type: Sequelize.STRING, defaultValue: 'Message' },
  createdAt: { type: Sequelize.STRING, defaultValue: new Date().toISOString() },
  updatedAt: { type: Sequelize.STRING, defaultValue: new Date().toISOString() },
  
  threadId: { type: Sequelize.STRING, allowNull: false },
  senderId: { type: Sequelize.STRING, allowNull: false },
  dateSent: { type: Sequelize.STRING, allowNull: false },
},{
  freezeTableName: true,
})

const LikeModel = db.define('Like', {
  id: { type: Sequelize.UUIDV4, primaryKey: true, defaultValue: uuid() },
  __typename: { type: Sequelize.STRING, defaultValue: 'Like' },
  createdAt: { type: Sequelize.STRING, defaultValue: new Date().toISOString() },
  updatedAt: { type: Sequelize.STRING, defaultValue: new Date().toISOString() },
  
  songId: { type: Sequelize.STRING, allowNull: false },
  userId: { type: Sequelize.STRING, allowNull: false },
},{
  freezeTableName: true,
})

/**
 * Now that the models have been defined, we can now use Sequelize to define
 * object relationships through the fields we created. These relationships
 * are equivalent to 1:1, 1:M, M:1, and M:M, and allow us to more generally resolve objects
 * through GQL
 */

CircleModel.belongsToMany(UserModel, {
  targetKey: 'id',
  through: UCLinkModel, as: 'Users', foreignKey: 'linkCircleId' // Compound link from Circle to a general User through the UCLink node
})
CircleModel.hasOne(UserModel, {through: UCLinkModel, as: 'Owner', foreignKey: 'id', targetKey: 'ownerId'}) // Compound link to the owner User
CircleModel.hasMany(SongModel, {as: 'Playlist', foreignKey: 'circleId'}) // Playlist Songs from Circle
CircleModel.hasMany(SongModel, {as: 'Removed', foreignKey: 'removedId'}) // Removed Songs from Circle
CircleModel.hasMany(SwapModel, {as: 'Swaps', foreignKey: 'circleId'}) // Active Swaps from Circle
CircleModel.hasMany(ActionModel, {as: 'History', foreignKey:'circleId'}) // Action History from Circle

UserModel.belongsToMany(CircleModel, {
  through: UCLinkModel, as: 'Circles', foreignKey: 'linkUserId' // Reverse link from generic User to Cirlces
})
UserModel.belongsToMany(ThreadModel, {
  through: UTLinkModel, as:'Threads', foreignKey: 'userId' // Link from User to Thread
})
UserModel.hasMany(ActionModel, {as: 'Notifications', foreignKey: 'notificationUserId'}) // Link from User to Action (notifications)

// Allows us to take a UC link and get the objects it refers to 
UCLinkModel.belongsTo(UserModel, {as:'User', foreignKey: 'linkUserId', targetKey: 'id'}) // Link from UCLink to User
UCLinkModel.belongsTo(CircleModel, {as:'Circle', foreignKey: 'linkCircleId', targetKey: 'id'}) // Link from UCLink to Circle

SongModel.belongsTo(CircleModel, {foreignKey: 'circleId', targetKey: 'id'}) // Link from Song to the Circle (playlist)
SongModel.hasMany(CommentModel, {as: 'Comments', foreignKey: 'songId'}) // Link from Song to its Comments
SongModel.belongsTo(UserModel, {as: 'Adder', foreignKey: 'adderId'}) // Link from Song to the adding User
SongModel.hasMany(LikeModel, {as: 'Likes', foreignKey: 'songId'}) // Link from Song to its Likes

ActionModel.belongsTo(CircleModel, {foreignKey: 'circleId', targetKey: 'id'}) // Action to Circle (parent)
ActionModel.belongsTo(UserModel, {as: 'Owner', foreignKey: 'ownerId'}) // Action to User (author)

SwapModel.belongsTo(CircleModel, {foreignKey: 'circleId', targetKey: 'id'}) // Swap to Circle (parent)
SwapModel.belongsTo(UserModel, {as: 'Author', foreignKey: 'authorId'}) // Swap to User (author)
SwapModel.belongsTo(SongModel, {as: 'Original', foreignKey: 'originalId'}) // 
SwapModel.belongsTo(SongModel, {as: 'Replacement', foreignKey: 'replacementId'})

CommentModel.belongsTo(SongModel, {foreignKey: 'songId', targetKey: 'id'})
CommentModel.belongsTo(UserModel, {as: 'Author', foreignKey: 'authorId'})

// Allows us to take a UTLink and traverse to the objects it refers to
UTLinkModel.belongsTo(UserModel, {foreignKey: 'userId', targetKey: 'id'})
UTLinkModel.belongsTo(ThreadModel, {foreignKey: 'threadId', targetKey: 'id'})

// Li
ThreadModel.belongsToMany(UserModel, {
  through: UTLinkModel, as: 'Users', foreignKey: 'threadId'
})
ThreadModel.hasMany(MessageModel, {as: 'Messages', foreignKey: 'threadId'})

MessageModel.belongsTo(ThreadModel, {as:'Thread', foreignKey: 'threadId'})
MessageModel.belongsTo(UserModel, {as:'Sender', foreignKey:'senderId'})

LikeModel.belongsTo(SongModel, {as: 'Song', foreignKey:'songId'})
LikeModel.belongsTo(UserModel, {as: 'User', foreignKey:'userId'})


const models = {
  Circle:   CircleModel,
  User:     UserModel,
  UCLink:   UCLinkModel,
  Song:     SongModel,
  Action:   ActionModel,
  Swap:     SwapModel,
  Comment:  CommentModel,
  UTLink:   UTLinkModel,
  Thread:   ThreadModel,
  Message:  MessageModel,
  Like:     LikeModel,
}

module.exports = models